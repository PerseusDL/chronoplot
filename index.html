<!DOCTYPE html>
<html>
<meta charset="utf-8">
<body>

<div id="selectorFilter">
	<input type="text" placeholder="filter" />
	<div id="selector"></div>
	<a href="" id="clear">Clear All</a>
</div>

<!--- Javascript and CSS -->
<script src="http://d3js.org/d3.v3.min.js"></script>
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
<script src="third_party/jslib/src/js/ArrayExt.js"></script>
<script src="third_party/jslib/src/js/jQueryPlus.js"></script>
<script src="third_party/jslib/src/js/DateConvert.js"></script>

<style type="text/css">
body { margin:0; }
h1 {
	margin-top:50px;
	margin-bottom:0;
	padding:0 0 0 20px;
}
#selectorFilter {
	right:0;
	top:0;
	position:fixed;
	background-color:#EEE;
	padding:10px;
	height:100%;
	width:215px;
}
#selectorFilter input {
	margin-bottom:10px;
}
#selector {
	/* font-size: 18px; */
	height:75%;
	overflow-y:scroll;
}
.gray {
	color: #AAA;
}
.axis path,
.axis line {
	fill:none;
	stroke:black;
	shape-rendering:crispEdges;
}
.axis text {
	font-family:sans-serif;
	font-size:11px;
}
path.line {
	fill:none;
	stroke:#FF0000;
}
</style>

<script>

// Gobal vars
var raw = null;
var arrext = new ArrayExt;
var year_offset = 0;
var check = [];
var filter_check = [];

// Get the JSON
$.ajax({
//	url: 'data/TI_Onomastic_sample.json',
//	url: 'data/TI_Onomastic.json',
	url: 'data/TI_Onomastic_clean.json',
	dataType: 'json',
	success: function( _data, _status ) {
		raw = _data;
		buildSelector( _data, "nisba" );
	},
	error: function( _error ) {
		alert( 'Error getting data file' );
		console.log( _error );
	}
});

function filterTextbox() {
	$('#selectorFilter input').on( 'keyup', function( _e ) {
		$('#selector .item').hide();
		var val = $( this ).val();
		if ( val == '' ) {
			$('#selector .item').show();
		}
		for ( var i=0; i<filter_check.length; i++ ) {
			if ( filter_check[i].indexOf( val ) != -1 ) {
				var split = filter_check[i].split(':');
				$('#selector .item input[value="'+split[0]+'"]').parent().show();
			}
		}
	})
}

function update() {
	mark();
	chart( filter(raw) );
	$.scrollToBottom(.5);
}

function buildSelector( _data, _key ) {
	var words = uniqWords( _data, _key );
	for ( var arab in words ) {
		
		// Build the selector item
		var extra = '';
		if ( words[arab] != null ) {
			extra = " <span class=\"gray\">"+words[arab]+"</span>";
		}
		var item = '<div class="item"><input type="checkbox" value="'+arab+'">'+arab+extra+"</div>";
		$('#selector').append( item );
		
		// Build the filter check
		filter_check.push( arab+":"+words[arab] );
	}
	selectorClick();
	filterTextbox();
}

function mark() {
	$('body').append( "<h1>"+check.join(' ' )+"</h1>" );
}

function selectorClick() {
	$('#selector input:checkbox').change( function() {
		var val = $(this).attr('value');
		if ( $(this).prop('checked') ) {
			if ( $.inArray( val, check ) == -1 ) {
				check.push( val );
			}
		}
		else {
			check = arrext.exile( check, [ val ] );
		}
		update();
	});
	$('#clear').on( 'touchstart click', function( _e ) {
		_e.preventDefault();
		$('#selector input:checkbox').attr("checked",false);
		check = [];
	})
}

// Unique Words
function uniqWords( _data, _key ) {
	var filter = {};
	for ( var i=0, ii=_data.length; i<ii; i++ ) {
		var key = _data[i]["nisba"];
		var phon = _data[i]["phonetic"];
		if ( key != null ) {
			filter[ key ] = phon;
		}
	}
	return filter;
}

// Filter items
function filter( _data ) {
	var match = [];
	for ( var i=0,ii=_data.length; i<ii; i++ ) {
		if ( $.inArray( _data[i]["nisba"], check ) != -1 ) {
			match.push( _data[i] );
		}
	}
	return match;
}

// Build the D3 chart
function chart( _data ) {
	var width = 800;
	var height = 600;
	var padding = 50;
	
	// Build the drawing area
	var svg = d3.select( "body" ).append( "svg:svg" )
		.attr( "width", width+padding )
		.attr( "height", height+padding )
	
	var freqFn = function(d){ return d.freq }
	var dateFn = function(d){ return d.dateAH }
	var nisbaFn = function(d){ return d.nisba }
	
	// X variable
	var x = d3.scale.linear()
		.range([ padding, width-padding ])
		.domain( [0, d3.max(_data, dateFn)-1] )
		
	var xAxis = d3.svg.axis()
		.scale( x )
		.orient( "bottom" )
		.ticks( 20 )
	
	var xMap = function(d){ return x( dateFn(d)-year_offset ) }
	
	// Y variable
	var y = d3.scale.linear()
		.range([ height-padding, padding ])
 		.domain([ 0, d3.max( _data, freqFn ) ])
		
	var yAxis = d3.svg.axis()
		.scale( y )
		.orient( "left" )
		.ticks( 5 )
	
	var yMap = function(d){ return x( freqFn(d) ) }
	
	// Translate
	var translate = function(d){ return "translate("+x(freqFn(d))+","+y(freqFn(d))+")" }

	// Build the axes
	// xAxis
	svg.append("g")
		.attr("class", "x axis")
		.attr("transform", "translate(0," + (height-padding) + ")" )
		.call( xAxis )
	.append("text")
		.attr("class", "label")
		.attr("x", width-padding)
		.attr("y", padding*.75)
		.style("text-anchor", "end")
		.text("DateAH");
		
	// yAxis
	svg.append("g")
		.attr("class", "y axis")
		.call( yAxis )
		.attr("transform", "translate(" + (padding) + ", 0 )" )
	.append("text")
		.attr("class", "label")
		.attr("transform", "rotate(-90)")
		.attr("y", padding*-.75 )
		.attr("x", padding*-1 )
		.attr("dy", ".71em")
		.style("text-anchor", "end")
		.text("Frequency");
	
	// Plot the points
	svg.selectAll( "circle" ).data( _data ).enter()
		.append( "svg:circle" )
			.attr( "r",2 )
			.attr( "cx", function(d){ return x(dateFn(d)) })
			.attr( "cy", function(d){ return y(freqFn(d)) })
		.append( "text" )
			.attr( "transform", function(d){ return translate(d) })
			.text( function(d){ return nisbaFn(d) })
	
	// Render the loess curve
	svg.append("g")
		.append('path')
			.datum( 
				function() {
					var xValues = _data.map( xMap );
					var yValues = _data.map( yMap );
					return loess( xValues, yValues, 0.25 );
				}
			)
			.attr('class', 'line')
			.attr('d', 
				d3.svg.line()
					.x( function(d){ return x(d[0]) } )
					.y( function(d){ return y(d[1]) } )
					.interpolate('basis')
			)
}

//adapted from the LoessInterpolator in org.apache.commons.math
function loess_pairs( pairs, bandwidth ) {
  var xval = pairs.map(function(pair){return pair[0]});
  var yval = pairs.map(function(pair){return pair[1]});
  var res = loess(xval, yval, bandwidth);
  return xval.map(function(x,i){return [x, res[i]]});
}
 
function loess( xval, yval, bandwidth ) {
	function tricube(x) {
		var tmp = 1 - x * x * x;
		return tmp * tmp * tmp;
	}
	
	var res = [];
	var left = 0;
	var right = Math.floor( bandwidth * xval.length ) - 1;
 
	for ( var i in xval ) {
		
		var x = xval[i];
		if ( i > 0 ) {
			if ( right < xval.length - 1 &&
				xval[right+1] - xval[i] < xval[i] - xval[left] ) {
				left++;
				right++;
			}
		}
 
		var edge;
		if ( xval[i] - xval[left] > xval[right] - xval[i] ) {
			edge = left;
		}
		else {
			edge = right;
		}
 
		var denom = Math.abs( 1.0 / ( xval[edge] - x ) );
		var sumWeights = 0;
		var sumX = 0, sumXSquared = 0, sumY = 0, sumXY = 0;
 
		var k = left;
		while( k <= right ) {
			var xk = xval[k];
			var yk = yval[k];
			var dist;
			
			if (k < i) {
				dist = (x - xk);
			} else {
				dist = (xk - x);
			}
			
			var w = tricube( dist * denom );
			var xkw = xk * w;
			sumWeights += w;
			sumX += xkw;
			sumXSquared += xk * xkw;
			sumY += yk * w;
			sumXY += yk * xkw;
			k++;
		}
 
		var meanX = sumX / sumWeights;
		var meanY = sumY / sumWeights;
		var meanXY = sumXY / sumWeights;
		var meanXSquared = sumXSquared / sumWeights;
 
		var beta;
		if ( meanXSquared == meanX * meanX ) {
			beta = 0;
		}
		else {
			beta = (meanXY - meanX * meanY) / (meanXSquared - meanX * meanX);
		}
		
		var alpha = meanY - beta * meanX;
		var val = beta * x + alpha;
		
		// Figure out why this is happening.
		if ( isNaN( val ) || val < 0 ) {
			console.log([ 'BAD', xval[i], yval[i], val, denom ]);
		}
		else {
			res.push([ xval[i], val ]);
		}
	}
	return res;
}
</script>
</body>
</html>